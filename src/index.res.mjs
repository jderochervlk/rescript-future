// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function make(lazyPromise, cancelled) {
  var cancelled$1 = Core__Option.getOr(cancelled, {
        contents: false
      });
  return {
          value: (function () {
              var tmp;
              try {
                tmp = lazyPromise();
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                tmp = new Promise((function (param, rej) {
                        rej(e);
                      }));
              }
              return tmp.then(function (t) {
                            return {
                                    TAG: "Ok",
                                    _0: t
                                  };
                          }).catch(function (e) {
                          return {
                                  TAG: "Error",
                                  _0: e
                                };
                        });
            }),
          cancelled: cancelled$1
        };
}

function map(future, fn) {
  return {
          value: (function () {
              return future.value().then(function (t) {
                          if (typeof t !== "object") {
                            return "Cancelled";
                          } else if (t.TAG === "Ok") {
                            if (future.cancelled.contents) {
                              return "Cancelled";
                            } else {
                              return {
                                      TAG: "Ok",
                                      _0: fn(t._0)
                                    };
                            }
                          } else {
                            return {
                                    TAG: "Error",
                                    _0: t._0
                                  };
                          }
                        });
            }),
          cancelled: future.cancelled
        };
}

function fold(future, errorFn, successFn, cancelledFnOpt) {
  var cancelledFn = cancelledFnOpt !== undefined ? cancelledFnOpt : (function () {
        console.info("future was cancelled");
      });
  return future.value().then(function (t) {
              if (typeof t !== "object") {
                return cancelledFn();
              } else if (t.TAG === "Ok") {
                return successFn(t._0);
              } else {
                return errorFn(t._0);
              }
            });
}

function cancel(t) {
  t.contents = true;
}

var t1 = {
  contents: false
};

function fn() {
  return fold(map(make((function () {
                        return fetch("http://httpstat.us/200?sleep=100");
                      }), t1), (function (res) {
                    return res;
                  })), (function (prim) {
                console.log(prim);
              }), (function (prim) {
                console.log(prim);
              }), undefined);
}

fn();

t1.contents = true;

export {
  make ,
  map ,
  fold ,
  cancel ,
  t1 ,
  fn ,
}
/*  Not a pure module */
